/**
 * A benchmark that implements a many-to-many message passing scenario. Several
 * workers are created, each of which sends a ping message to one other worker.
 * To which worker the ping message is sent is decided randomly. The worker
 * who receives the ping message replies with a pong. Uppon receiving the pong,
 * the worker sends the next ping message.
 *
 * In LF, the challenging aspect about this benchmark is its sparse activity.
 * While each worker is connected to all other workers, it will only send a
 * message to precisely one of them for each tag. Since we need to ensure that
 * input ports have a single writer, each worker has to create multiport inputs,
 * where each port instance corresponds to one potential source of ping or pong
 * messages. In order to determine from which worker we received a ping or pong
 * message, we need to iterate over all ports and check `if_present()`. However,
 * this becomes very expensive for a large number of workers. For 120 workers we
 * send a total of 120 pings and 120 pongs per iteration, but we need to check
 * up to 14400 ping ports and 14400 pong ports in each iteration. Obviously this
 * introduces a large overhead.
 *
 * @author Hannes Klein
 * @author Felix Wittwer
 * @author Christian Menard
 */


target Cpp {
    build-type : Release,
    no-runtime-validation: true,
    cmake-include: "../IncludeHeaders.cmake",
    logging: Warn,
};

import BenchmarkRunner from "../BenchmarkRunner.lf";

public preamble {=
    enum MsgType {
      PingMsg,
      PongMsg,
    };
=}

// Despite the name, this only collects "finished" messages from all workers
// and lets the benchmark runner know when all the workers finished
reactor Sink(numWorkers:size_t(10)) {
    // number of exit messages received
    state numMessages: size_t(0);
    
    input start: void;
    output finished: void;
    
    input[numWorkers] workerFinished :void;
    
    reaction(start) {=
        // reset state
        numMessages = 0;
    =}
    
    reaction(workerFinished) -> finished {=
        // collect all exit messages
        for(const auto& port : workerFinished) {
            if(port.is_present()) {
                numMessages += 1;
                if(numMessages == numWorkers) {
                    finished.set();
                    return;
                }
            }
        }
    =}
}

reactor InnerWorker(bank_index: size_t{0}, worker_id: size_t{0}) {
    input inPing: void;
    input inPong: void;
    input expectPong: void;
    output outPong: void;

    reaction(inPing) -> outPong {=
        reactor::log::Info() << "Worker " << worker_id << " received ping from " << bank_index << '\n';
        outPong.set();
    =}

    reaction(inPong) expectPong {=
        reactor::log::Info() << "Worker " << worker_id << " received pong from " << bank_index << '\n';
        if(!expectPong.is_present()) {
            reactor::log::Error() << "Worker " << worker_id << " did not expect pong from " << bank_index << '\n';
        }
    =}
}

reactor Worker(bank_index: size_t(0), numMessages: size_t(20000), numWorkers:size_t(10)) {
    
    public preamble {=
        #include "PseudoRandom.hh"
    =}
    
    state numPings: size_t{0};
    state random: PseudoRandom;
    state expPong: size_t{{=SIZE_MAX=}}
    
    input[numWorkers] inPing: void;
    input[numWorkers] inPong: void;
    output[numWorkers] outPing: void;
    output[numWorkers] outPong: void;
    
    input start: void;
    output finished:void;
    
    logical action next;

    inner = new[numWorkers] InnerWorker(worker_id=bank_index);
    
    // send ping
    reaction (next) -> outPing, inner.expectPong {=
        numPings++;
        auto to = random.nextInt(numWorkers);
        expPong = to;
        outPing[to].set();
        inner[to].expectPong.set();
        reactor::log::Info() << "Worker " << bank_index << " sends ping to " << to << '\n';
    =}

    inPing -> inner.inPing;
    inPong -> inner.inPong;
    inner.outPong -> outPong;
    
    // schedule next ping after receiving pong
    reaction (inPong) -> next, finished {=
        reactor::log::Info() << "Worker " << bank_index << " schedules next\n";
        if (numPings == numMessages) {
            finished.set();
        } else {
            next.schedule();
        }
    =}
    
    reaction (start) -> next {=
        // reset state
        numPings = 0;
        expPong = SIZE_MAX;
        random = PseudoRandom(bank_index);
        
        // start execution
        next.schedule();
    =}
}

main reactor (numIterations:size_t(12), numPingsPerReactor:size_t(20000), numReactors:size_t(120)) {

    runner = new BenchmarkRunner(numIterations=numIterations);
    sink = new Sink(numWorkers=numReactors);
    worker = new[numReactors] Worker(numMessages=numPingsPerReactor, numWorkers=numReactors);
    
    reaction(startup) {=
        printBenchmarkInfo("BigReactorLFCppBenchmark");
        printArgs("numIterations", numIterations, "numPingsPerReactor", numPingsPerReactor, "numReactors", numReactors);
        printSystemInfo();
    =}
        
    (runner.start)+ -> sink.start, worker.start;
    worker.finished -> sink.workerFinished;
    sink.finished -> runner.finished;
    
    worker.outPing -> interleaved(worker.inPing);    
    worker.outPong -> interleaved(worker.inPong);
}
